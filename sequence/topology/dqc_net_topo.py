from .multihop_topo import MultihopTopo
from .node import BSMNode, DQCNode
from ..constants import *


class DQCNetTopo(MultihopTopo):
    """Class for generating distributed quantum computing network with distributed quantum computing nodes

    Class DQCNetTopo is the child of class MultihopTopo. Distributed quantum computing nodes, BSM
    nodes, quantum channels, classical channels and timeline for simulation
    could be generated by using this class.

    Attributes:
        bsm_to_router_map (dict[str, list[Node]]): mapping of bsm node to two connected routers
        nodes (dict[str, list[Node]]): mapping of type of node to a list of same type node.
        qchannels (list[QuantumChannel]): list of quantum channel objects in network.
        cchannels (list[ClassicalChannel]): list of classical channel objects in network.
        tl (Timeline): the timeline used for simulation
    """

    _BSM_NAME_TEMPLATE = "BSM.{}.{}.auto"
    _ROUTER_NODE_TYPE = DQC_NODE

    def _add_nodes(self, config: dict):
        for node in config[ALL_NODE]:
            seed = node[SEED]
            node_type = node[TYPE]
            name = node[NAME]
            template_name = node.get(TEMPLATE, None)
            template = self.templates.get(template_name, {})

            if node_type == BSM_NODE:
                others = self.bsm_to_router_map[name]
                node_obj = BSMNode(name, self.tl, others, component_templates=template)
            elif node_type == DQC_NODE:
                data_size = node.get(DATA_MEMO_ARRAY_SIZE, 0)
                comm_size = node.get(MEMO_ARRAY_SIZE, 0)
                node_obj = DQCNode(name, self.tl, memo_size=comm_size, data_memo_size=data_size, component_templates=template)
            else:
                raise ValueError(f"Unknown type of node '{node_type}'")

            node_obj.set_seed(seed)
            self.nodes[node_type].append(node_obj)

    def infer_qubit_to_node(self, total_wires: int) -> dict[int, str]:
        """Auto-infer the {wire_index: node_name} map by
           first assigning every node's n_data qubits in JSON order, then every node's n_ancilla qubits.

        Args:
            total_wires (int): The total number of wires (qubits) in the system.
        Returns:
            dict[int, str]: A mapping from wire indices to node names.
        """
        mapping: dict[int, str] = {}
        next_wire = 0
        # 1) data wires
        for nd in self._raw_cfg["nodes"]:
            name   = nd["name"]
            n_data = nd.get("n_data", 1)
            for _ in range(n_data):
                if next_wire >= total_wires:
                    raise ValueError(f"Mapping overflow: more data qubits than {total_wires}")
                mapping[next_wire] = name
                next_wire += 1
        # 3) (optionally) any communication‐only qubits, etc.
        #    If your circuit has exactly data+ancilla qubits, you can assert:
        if next_wire != total_wires:
            raise ValueError(f"Configured for {next_wire} wires but circuit has {total_wires}")
        return mapping

    def infer_memory_owners(self, total_wires:  int, ancilla_inds: list[int]) -> tuple[dict[str,dict[int,int]], dict[str,dict[int,int]]]:
        """ Returns (data_owners, ancilla_owners) where each is node_name → { wire_index: slot_index_in_memory_array }.

        Args:
            total_wires (int): The total number of wires (qubits) in the system.
            ancilla_inds (list[int]): The list of indices for the ancilla qubits.
        """
        qubit_to_node = self.infer_qubit_to_node(total_wires)

        data_owners    = {name:{} for name in self.nodes.keys()}

        for q, owner in qubit_to_node.items():
            slot = len(data_owners[owner])
            data_owners[owner][q] = slot

        return data_owners
