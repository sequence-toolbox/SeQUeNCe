import json
import numpy as np
from networkx import Graph, dijkstra_path, exception

from .topology import Topology as Topo
from ..kernel.timeline import Timeline
from .node import BSMNode
from ..constants import SPEED_OF_LIGHT
from .const_topo import (
    BSM_NODE, MEET_IN_THE_MID, MEMO_ARRAY_SIZE, CONTROLLER,
    DQC_NODE, DATA_MEMO_ARRAY_SIZE,
    STOP_TIME, ALL_Q_CHANNEL, SRC, DST, ALL_NODE, SEED, TYPE, NAME,
    TEMPLATE, ALL_Q_CONNECT, CONNECT_NODE_1, CONNECT_NODE_2,
    ATTENUATION, DISTANCE, ALL_C_CHANNEL, DELAY, ALL_C_CONNECT,
)
from typing import Dict, List, Type
from .node import Node, DQCNode


class DQCNetTopo(Topo):
    """Class for generating distributed quantum computing network with distributed quantum computing nodes

    Class DQCNodeNetTopo is the child of class Topology. Distributed quantum computing nodes, BSM
    nodes, quantum channels, classical channels and timeline for simulation
    could be generated by using this class.

    Attributes:
        bsm_to_router_map (dict[str, list[Node]]): mapping of bsm node to two connected routers
        nodes (dict[str, list[Node]]): mapping of type of node to a list of same type node.
        qchannels (list[QuantumChannel]): list of quantum channel objects in network.
        cchannels (list[ClassicalChannel]): list of classical channel objects in network.
        tl (Timeline): the timeline used for simulation
    """

    _deprecated_attrs = {
        "BSM_NODE": BSM_NODE,
        "MEET_IN_THE_MID": MEET_IN_THE_MID,
        "MEMO_ARRAY_SIZE": MEMO_ARRAY_SIZE,
        "CONTROLLER": CONTROLLER,
        "DQC_NODE": DQC_NODE,
        "DATA_MEMO_ARRAY_SIZE": DATA_MEMO_ARRAY_SIZE,
    }

    def __init__(self, conf_file_name: str):
        self.encoding_type = None
        super().__init__(conf_file_name)

    def _map_bsm_routers(self, config):
        for qc in config[ALL_Q_CHANNEL]:
            src, dst = qc[SRC], qc[DST]
            if dst in self.bsm_to_router_map:
                self.bsm_to_router_map[dst].append(src)
            else:
                self.bsm_to_router_map[dst] = [src]

    def _add_bsm_node_to_router(self):
        for bsm in self.bsm_to_router_map:
            r0_str, r1_str = self.bsm_to_router_map[bsm]
            r0 = self.tl.get_entity_by_name(r0_str)
            r1 = self.tl.get_entity_by_name(r1_str)
            if r0 is not None:
                r0.add_bsm_node(bsm, r1_str)
            if r1 is not None:
                r1.add_bsm_node(bsm, r0_str)

    def _add_nodes(self, config: dict):
        for node in config[ALL_NODE]:
            seed = node[SEED]
            node_type = node[TYPE]
            name = node[NAME]
            template_name = node.get(TEMPLATE, None)
            template = self.templates.get(template_name, {})

            if node_type == BSM_NODE:
                others = self.bsm_to_router_map[name]
                node_obj = BSMNode(name, self.tl, others, component_templates=template)
            elif node_type == DQC_NODE:
                data_size = node.get(DATA_MEMO_ARRAY_SIZE, 0)
                comm_size = node.get(MEMO_ARRAY_SIZE, 0)
                node_obj = DQCNode(name, self.tl, memo_size=comm_size, data_memo_size=data_size, component_templates=template)
            else:
                raise ValueError(f"Unknown type of node '{node_type}'")

            node_obj.set_seed(seed)
            self.nodes[node_type].append(node_obj)

    def _add_qconnections(self, config: dict):
        """generate bsm_info, qc_info, and cc_info for the q_connections."""
        for q_connect in config.get(ALL_Q_CONNECT, []):
            node1 = q_connect[CONNECT_NODE_1]
            node2 = q_connect[CONNECT_NODE_2]
            attenuation = q_connect[ATTENUATION]
            distance = q_connect[DISTANCE] // 2
            channel_type = q_connect[TYPE]
            cc_delay = []                                   # generate classical channel delay
            for cc in config.get(ALL_C_CHANNEL, []):   # classical channel
                if cc[SRC] == node1 and cc[DST] == node2:
                    delay = cc.get(DELAY, cc.get(DISTANCE, 1000) / SPEED_OF_LIGHT)
                    cc_delay.append(delay)
                elif cc[SRC] == node2 and cc[DST] == node1:
                    delay = cc.get(DELAY, cc.get(DISTANCE, 1000) / SPEED_OF_LIGHT)
                    cc_delay.append(delay)

            for cc in config.get(ALL_C_CONNECT, []):  # classical connection
                if (cc[CONNECT_NODE_1] == node1 and cc[CONNECT_NODE_2] == node2) \
                        or (cc[CONNECT_NODE_1] == node2 and cc[CONNECT_NODE_2] == node1):
                    delay = cc.get(DELAY, cc.get(DISTANCE, 1000) / SPEED_OF_LIGHT)
                    cc_delay.append(delay)
            if len(cc_delay) == 0:
                assert 0, q_connect
            cc_delay = np.mean(cc_delay) // 2

            if channel_type == MEET_IN_THE_MID:
                bsm_name = f"BSM.{node1}.{node2}.auto"  # the intermediate BSM node
                bsm_seed = q_connect.get(SEED, 0)
                bsm_template_name = q_connect.get(TEMPLATE, None)
                bsm_info = {NAME: bsm_name,
                            TYPE: BSM_NODE,
                            SEED: bsm_seed,
                            TEMPLATE: bsm_template_name}
                config[ALL_NODE].append(bsm_info)

                for src in [node1, node2]:
                    qc_name = f"QC.{src}.{bsm_name}"  # the quantum channel
                    qc_info = {NAME: qc_name,
                               SRC: src,
                               DST: bsm_name,
                               DISTANCE: distance,
                               ATTENUATION: attenuation}
                    if ALL_Q_CHANNEL not in config:
                        config[ALL_Q_CHANNEL] = []
                    config[ALL_Q_CHANNEL].append(qc_info)

                    cc_name = f"CC.{src}.{bsm_name}"  # the classical channel
                    cc_info = {NAME: cc_name,
                               SRC: src,
                               DST: bsm_name,
                               DISTANCE: distance,
                               DELAY: cc_delay}
                    if ALL_C_CHANNEL not in config:
                        config[ALL_C_CHANNEL] = []
                    config[ALL_C_CHANNEL].append(cc_info)

                    cc_name = f"CC.{bsm_name}.{src}"
                    cc_info = {NAME: cc_name,
                               SRC: bsm_name,
                               DST: src,
                               DISTANCE: distance,
                               DELAY: cc_delay}
                    config[ALL_C_CHANNEL].append(cc_info)
            else:
                raise NotImplementedError("Unknown type of quantum connection")

    def _generate_forwarding_table(self, config: dict):
        """For static routing."""
        graph = Graph()
        for node in config[ALL_NODE]:
            if node[TYPE] == DQC_NODE:
                graph.add_node(node[NAME])

        costs = {}
        for qc in self.qchannels:
            router, bsm = qc.sender.name, qc.receiver
            if bsm not in costs:
                costs[bsm] = [router, qc.distance]
            else:
                costs[bsm] = [router] + costs[bsm]
                costs[bsm][-1] += qc.distance

        graph.add_weighted_edges_from(costs.values())
        for src in self.nodes[DQC_NODE]:
            for dst_name in graph.nodes:
                if src.name == dst_name:
                    continue
                try:
                    if dst_name > src.name:
                        path = dijkstra_path(graph, src.name, dst_name)
                    else:
                        path = dijkstra_path(graph, dst_name, src.name)[::-1]
                    next_hop = path[1]
                    # routing protocol locates at the bottom of the stack
                    routing_protocol = src.network_manager.get_routing_protocol()
                    routing_protocol.add_forwarding_rule(dst_name, next_hop)
                except exception.NetworkXNoPath:
                    pass

    def infer_qubit_to_node(self, total_wires: int) -> dict[int, str]:
        """Auto-infer the {wire_index: node_name} map by 
           first assigning every node's n_data qubits in JSON order, then every node's n_ancilla qubits.
        
        Args:
            total_wires (int): The total number of wires (qubits) in the system.
        Returns:
            dict[int, str]: A mapping from wire indices to node names.
        """
        mapping: dict[int, str] = {}
        next_wire = 0
        # 1) data wires
        for nd in self._raw_cfg["nodes"]:
            name   = nd["name"]
            n_data = nd.get("n_data", 1)
            for _ in range(n_data):
                if next_wire >= total_wires:
                    raise ValueError(f"Mapping overflow: more data qubits than {total_wires}")
                mapping[next_wire] = name
                next_wire += 1
        # 3) (optionally) any communication‐only qubits, etc.
        #    If your circuit has exactly data+ancilla qubits, you can assert:
        if next_wire != total_wires:
            raise ValueError(f"Configured for {next_wire} wires but circuit has {total_wires}")
        return mapping
    
    def infer_memory_owners(self, total_wires:  int, ancilla_inds: list[int]) -> tuple[dict[str,dict[int,int]], dict[str,dict[int,int]]]:
        """ Returns (data_owners, ancilla_owners) where each is node_name → { wire_index: slot_index_in_memory_array }.

        Args:
            total_wires (int): The total number of wires (qubits) in the system.
            ancilla_inds (list[int]): The list of indices for the ancilla qubits.
        """
        qubit_to_node = self.infer_qubit_to_node(total_wires)

        data_owners    = {name:{} for name in self.nodes.keys()}

        for q, owner in qubit_to_node.items():
            slot = len(data_owners[owner])
            data_owners[owner][q] = slot

        return data_owners

    def get_timeline(self) -> Timeline:
        return self.tl

    def get_nodes(self) -> dict[str, list[Node]]:
        return self.nodes  
