import json
import numpy as np
from networkx import Graph, dijkstra_path, exception

from ..network_management.routing_distributed import DistributedRoutingProtocol
from ..network_management.routing_static import StaticRoutingProtocol
from .topology import Topology as Topo
from ..kernel.timeline import Timeline
from ..kernel.quantum_manager import KET_STATE_FORMALISM, QuantumManager
from .node import BSMNode, QuantumRouter
from ..constants import SPEED_OF_LIGHT
from .const_topo import (
    ALL_C_CHANNEL, ALL_C_CONNECT, ALL_NODE, ALL_Q_CHANNEL, ALL_Q_CONNECT,
    ATTENUATION, BSM_NODE, CONNECT_NODE_1, CONNECT_NODE_2, CONTROLLER,
    DELAY, DISTANCE, DST, FORMALISM, MEET_IN_THE_MID, MEMO_ARRAY_SIZE,
    NAME, PORT, PROC_NUM, QUANTUM_ROUTER, SEED, SRC, STOP_TIME,
    TEMPLATE, TRUNC, TYPE,
)


class RouterNetTopo(Topo):
    """Class for generating quantum communication network with quantum routers

    Class RouterNetTopo is the child of class Topology. Quantum routers, BSM
    nodes, quantum  channels, classical channels and timeline for simulation
    could be generated by using this class.

    Attributes:
        bsm_to_router_map (dict[str, list[Node]]): mapping of bsm node to two connected routers
        nodes (dict[str, list[Node]]): mapping of type of node to a list of same type node.
        qchannels (list[QuantumChannel]): list of quantum channel objects in network.
        cchannels (list[ClassicalChannel]): list of classical channel objects in network.
        tl (Timeline): the timeline used for simulation
    """

    _deprecated_attrs = {
        "BSM_NODE": BSM_NODE,
        "MEET_IN_THE_MID": MEET_IN_THE_MID,
        "MEMO_ARRAY_SIZE": MEMO_ARRAY_SIZE,
        "PORT": PORT,
        "PROC_NUM": PROC_NUM,
        "QUANTUM_ROUTER": QUANTUM_ROUTER,
        "CONTROLLER": CONTROLLER,
    }

    def __init__(self, conf_file_name: str):
        self.bsm_to_router_map = {}
        self.encoding_type = None
        super().__init__(conf_file_name)

    def _load(self, filename: str):
        with open(filename) as fh:
            config = json.load(fh)

        self._get_templates(config)
        # quantum connections are only supported by sequential simulation so far
        self._add_qconnections(config)
        self._add_timeline(config)
        self._map_bsm_routers(config)
        self._add_nodes(config)
        self._add_bsm_node_to_router()
        self._add_qchannels(config)
        self._add_cchannels(config)
        self._add_cconnections(config)
        self._generate_forwarding_table(config)

    def _add_timeline(self, config: dict):
        stop_time = config.get(STOP_TIME, 10 ** 23)
        formalism = config.get(FORMALISM, KET_STATE_FORMALISM)
        truncation = config.get(TRUNC, 1)
        QuantumManager.set_global_manager_formalism(formalism)
        self.tl = Timeline(stop_time=stop_time, truncation=truncation)

    def _map_bsm_routers(self, config):
        for qc in config[ALL_Q_CHANNEL]:
            src, dst = qc[SRC], qc[DST]
            if dst in self.bsm_to_router_map:
                self.bsm_to_router_map[dst].append(src)
            else:
                self.bsm_to_router_map[dst] = [src]

    def _add_nodes(self, config: dict):
        for node in config[ALL_NODE]:
            seed = node[SEED]
            node_type = node[TYPE]
            name = node[NAME]
            template_name = node.get(TEMPLATE, None)
            template = self.templates.get(template_name, {})

            if node_type == BSM_NODE:
                others = self.bsm_to_router_map[name]
                node_obj = BSMNode(name, self.tl, others, component_templates=template)
            elif node_type == QUANTUM_ROUTER:
                memo_size = node.get(MEMO_ARRAY_SIZE, 0)
                node_obj = QuantumRouter(name, self.tl, memo_size, component_templates=template)
            else:
                raise ValueError(f"Unknown type of node '{node_type}'")

            node_obj.set_seed(seed)
            self.nodes[node_type].append(node_obj)

    def _add_bsm_node_to_router(self):
        for bsm in self.bsm_to_router_map:
            r0_str, r1_str = self.bsm_to_router_map[bsm]
            r0 = self.tl.get_entity_by_name(r0_str)
            r1 = self.tl.get_entity_by_name(r1_str)
            if r0 is not None:
                r0.add_bsm_node(bsm, r1_str)
            if r1 is not None:
                r1.add_bsm_node(bsm, r0_str)

    def _add_qconnections(self, config: dict):
        """generate bsm_info, qc_info, and cc_info for the q_connections."""
        for q_connect in config.get(ALL_Q_CONNECT, []):
            node1 = q_connect[CONNECT_NODE_1]
            node2 = q_connect[CONNECT_NODE_2]
            attenuation = q_connect[ATTENUATION]
            distance = q_connect[DISTANCE] // 2
            channel_type = q_connect[TYPE]
            cc_delay = []                                   # generate classical channel delay
            for cc in config.get(ALL_C_CHANNEL, []):   # classical channel
                if cc[SRC] == node1 and cc[DST] == node2:
                    delay = cc.get(DELAY, cc.get(DISTANCE, 1000) / SPEED_OF_LIGHT)
                    cc_delay.append(delay)
                elif cc[SRC] == node2 and cc[DST] == node1:
                    delay = cc.get(DELAY, cc.get(DISTANCE, 1000) / SPEED_OF_LIGHT)
                    cc_delay.append(delay)

            for cc in config.get(ALL_C_CONNECT, []):  # classical connection
                if (cc[CONNECT_NODE_1] == node1 and cc[CONNECT_NODE_2] == node2) \
                        or (cc[CONNECT_NODE_1] == node2 and cc[CONNECT_NODE_2] == node1):
                    delay = cc.get(DELAY, cc.get(DISTANCE, 1000) / SPEED_OF_LIGHT)
                    cc_delay.append(delay)
            if len(cc_delay) == 0:
                assert 0, q_connect
            cc_delay = int(np.mean(cc_delay) // 2)

            if channel_type == MEET_IN_THE_MID:
                bsm_name = f"BSM.{node1}.{node2}"  # the intermediate BSM node
                bsm_seed = q_connect.get(SEED, 0)
                bsm_template_name = q_connect.get(TEMPLATE, None)
                bsm_info = {NAME: bsm_name,
                            TYPE: BSM_NODE,
                            SEED: bsm_seed,
                            TEMPLATE: bsm_template_name}
                config[ALL_NODE].append(bsm_info)

                for src in [node1, node2]:
                    qc_name = f"QC-{src}-{bsm_name}"  # the quantum channel
                    qc_info = {NAME: qc_name,
                               SRC: src,
                               DST: bsm_name,
                               DISTANCE: distance,
                               ATTENUATION: attenuation}
                    if ALL_Q_CHANNEL not in config:
                        config[ALL_Q_CHANNEL] = []
                    config[ALL_Q_CHANNEL].append(qc_info)

                    cc_name = f"CC-{src}-{bsm_name}"  # the classical channel
                    cc_info = {NAME: cc_name,
                               SRC: src,
                               DST: bsm_name,
                               DISTANCE: distance,
                               DELAY: cc_delay}
                    if ALL_C_CHANNEL not in config:
                        config[ALL_C_CHANNEL] = []
                    config[ALL_C_CHANNEL].append(cc_info)

                    cc_name = f"CC-{bsm_name}-{src}"
                    cc_info = {NAME: cc_name,
                               SRC: bsm_name,
                               DST: src,
                               DISTANCE: distance,
                               DELAY: cc_delay}
                    config[ALL_C_CHANNEL].append(cc_info)
            else:
                raise NotImplementedError("Unknown type of quantum connection")

    def _generate_forwarding_table(self, config: dict):
        """If static routing is chosen, then generate forwarding table for each quantum router based on Dijkstra's algorithm.
           If distributed routing is chosen, then initialize link cost for each quantum router and setup the FSM.

        Args:
            config (dict): the configuration dictionary used to generate the topology
        """
        # get the link cost
        graph = Graph()
        for node in config[ALL_NODE]:
            if node[TYPE] == QUANTUM_ROUTER:
                graph.add_node(node[NAME])

        costs = {}
        for qc in self.qchannels:
            router, bsm = qc.sender.name, qc.receiver
            if bsm not in costs:
                costs[bsm] = [router, qc.distance]
            else:
                costs[bsm] = [router] + costs[bsm]
                costs[bsm][-1] += qc.distance

        # check if all routers use static routing, if not, initialize distributed routing protocol
        routing_protocol = None
        for q_router in self.nodes[QUANTUM_ROUTER]:
            routing_protocol = q_router.network_manager.get_routing_protocol()
            break

        if isinstance(routing_protocol, StaticRoutingProtocol):
            # static routing, directly configure the forwarding tables
            graph.add_weighted_edges_from(costs.values())
            for src in self.nodes[QUANTUM_ROUTER]:
                for dst_name in graph.nodes:
                    if src.name == dst_name:
                        continue
                    try:
                        if dst_name > src.name:
                            path = dijkstra_path(graph, src.name, dst_name)
                        else:
                            path = dijkstra_path(graph, dst_name, src.name)[::-1]
                        next_hop = path[1]
                        # routing protocol locates at the bottom of the stack
                        routing_protocol = src.network_manager.get_routing_protocol()
                        routing_protocol.add_forwarding_rule(dst_name, next_hop)
                    except exception.NetworkXNoPath:
                        pass
    
        elif isinstance(routing_protocol, DistributedRoutingProtocol):
            # distributed routing, initialize the link cost and setup the FSM
            for q_router in self.nodes[QUANTUM_ROUTER]:
                routing_protocol: DistributedRoutingProtocol = q_router.network_manager.get_routing_protocol()
                for bsm, cost_info in costs.items():
                    if q_router.name in cost_info:
                        neighbor = cost_info[0] if cost_info[0] != q_router.name else cost_info[1]
                        cost = cost_info[2]
                        routing_protocol.link_cost[neighbor] = cost
                routing_protocol.init()
