import json

import numpy as np

from . import topology_constants as tc
from .node import BSMNode, QuantumRouter
from .topology import Topology as Topo
from ..constants import SPEED_OF_LIGHT
from ..kernel.quantum_manager import KET_STATE_FORMALISM, QuantumManager
from ..kernel.timeline import Timeline


class RouterNetTopo(Topo):
    """Class for generating quantum communication network with quantum routers

    Class RouterNetTopo is the child of class Topology. Quantum routers, BSM
    nodes, quantum  channels, classical channels and timeline for simulation
    could be generated by using this class. Different processes in the parallel
    simulation could use the same configuration file to generate network
    required for the parallel simulation.

    Attributes:
        bsm_to_router_map (dict[str, list[Node]]): mapping of bsm node to two connected routers
        nodes (dict[str, list[Node]]): mapping of type of node to a list of same type node.
        qchannels (list[QuantumChannel]): list of quantum channel objects in network.
        cchannels (list[ClassicalChannel]): list of classical channel objects in network.
        tl (Timeline): the timeline used for simulation
    """
    def __init__(self, conf_file_name: str):
        self.bsm_to_router_map = {}
        self.encoding_type = None
        super().__init__(conf_file_name)

    def _load(self, filename: str):
        with open(filename) as fh:
            config = json.load(fh)

        self._get_templates(config)
        # quantum connections are only supported by sequential simulation so far
        if not config[tc.IS_PARALLEL]:
            self._add_qconnections(config)
        self._add_timeline(config)
        self._map_bsm_routers(config)
        self._add_nodes(config)
        self._add_bsm_node_to_router()
        self._add_qchannels(config)
        self._add_cchannels(config)
        self._add_cconnections(config)
        self._generate_forwarding_table(config, tc.QUANTUM_ROUTER)

    def _add_timeline(self, config: dict):
        stop_time = config.get(tc.STOP_TIME, 10 ** 23)
        formalism = config.get(tc.FORMALISM, KET_STATE_FORMALISM)
        truncation = config.get(tc.TRUNC, 1)
        QuantumManager.set_global_manager_formalism(formalism)
        if config.get(tc.IS_PARALLEL, False):
            raise Exception("Please install 'psequence' package for parallel simulations.")
        else:
            self.tl = Timeline(stop_time=stop_time, truncation=truncation)

    def _map_bsm_routers(self, config):
        for qc in config[tc.ALL_Q_CHANNEL]:
            src, dst = qc[tc.SRC], qc[tc.DST]
            if dst in self.bsm_to_router_map:
                self.bsm_to_router_map[dst].append(src)
            else:
                self.bsm_to_router_map[dst] = [src]

    def _add_nodes(self, config: dict):
        for node in config[tc.ALL_NODE]:
            seed = node[tc.SEED]
            node_type = node[tc.TYPE]
            name = node[tc.NAME]
            template_name = node.get(tc.TEMPLATE, None)
            template = self.templates.get(template_name, {})

            if node_type == tc.BSM_NODE:
                others = self.bsm_to_router_map[name]
                node_obj = BSMNode(name, self.tl, others, component_templates=template)
            elif node_type == tc.QUANTUM_ROUTER:
                memo_size = node.get(tc.MEMO_ARRAY_SIZE, 0)
                node_obj = QuantumRouter(name, self.tl, memo_size, component_templates=template)
            else:
                raise ValueError(f"Unknown type of node '{node_type}'")

            node_obj.set_seed(seed)
            self.nodes[node_type].append(node_obj)

    def _add_bsm_node_to_router(self):
        for bsm in self.bsm_to_router_map:
            r0_str, r1_str = self.bsm_to_router_map[bsm]
            r0 = self.tl.get_entity_by_name(r0_str)
            r1 = self.tl.get_entity_by_name(r1_str)
            if r0 is not None:
                r0.add_bsm_node(bsm, r1_str)
            if r1 is not None:
                r1.add_bsm_node(bsm, r0_str)

    def _add_qconnections(self, config: dict):
        """generate bsm_info, qc_info, and cc_info for the q_connections."""
        for q_connect in config.get(tc.ALL_Q_CONNECT, []):
            node1 = q_connect[tc.CONNECT_NODE_1]
            node2 = q_connect[tc.CONNECT_NODE_2]
            attenuation = q_connect[tc.ATTENUATION]
            distance = q_connect[tc.DISTANCE] // 2
            channel_type = q_connect[tc.TYPE]
            cc_delay = []                                   # generate classical channel delay
            for cc in config.get(tc.ALL_C_CHANNEL, []):   # classical channel
                if cc[tc.SRC] == node1 and cc[tc.DST] == node2:
                    delay = cc.get(tc.DELAY, cc.get(tc.DISTANCE, 1000) / SPEED_OF_LIGHT)
                    cc_delay.append(delay)
                elif cc[tc.SRC] == node2 and cc[tc.DST] == node1:
                    delay = cc.get(tc.DELAY, cc.get(tc.DISTANCE, 1000) / SPEED_OF_LIGHT)
                    cc_delay.append(delay)

            for cc in config.get(tc.ALL_C_CONNECT, []):  # classical connection
                if (cc[tc.CONNECT_NODE_1] == node1 and cc[tc.CONNECT_NODE_2] == node2) \
                        or (cc[tc.CONNECT_NODE_1] == node2 and cc[tc.CONNECT_NODE_2] == node1):
                    delay = cc.get(tc.DELAY, cc.get(tc.DISTANCE, 1000) / SPEED_OF_LIGHT)
                    cc_delay.append(delay)
            if len(cc_delay) == 0:
                assert 0, q_connect
            cc_delay = np.mean(cc_delay) // 2

            if channel_type == tc.MEET_IN_THE_MID:
                bsm_name = f"BSM.{node1}.{node2}.auto"  # the intermediate BSM node
                bsm_seed = q_connect.get(tc.SEED, 0)
                bsm_template_name = q_connect.get(tc.TEMPLATE, None)
                bsm_info = {tc.NAME: bsm_name,
                            tc.TYPE: tc.BSM_NODE,
                            tc.SEED: bsm_seed,
                            tc.TEMPLATE: bsm_template_name}
                config[tc.ALL_NODE].append(bsm_info)

                for src in [node1, node2]:
                    qc_name = f"QC.{src}.{bsm_name}"  # the quantum channel
                    qc_info = {tc.NAME: qc_name,
                               tc.SRC: src,
                               tc.DST: bsm_name,
                               tc.DISTANCE: distance,
                               tc.ATTENUATION: attenuation}
                    if tc.ALL_Q_CHANNEL not in config:
                        config[tc.ALL_Q_CHANNEL] = []
                    config[tc.ALL_Q_CHANNEL].append(qc_info)

                    cc_name = f"CC.{src}.{bsm_name}"  # the classical channel
                    cc_info = {tc.NAME: cc_name,
                               tc.SRC: src,
                               tc.DST: bsm_name,
                               tc.DISTANCE: distance,
                               tc.DELAY: cc_delay}
                    if tc.ALL_C_CHANNEL not in config:
                        config[tc.ALL_C_CHANNEL] = []
                    config[tc.ALL_C_CHANNEL].append(cc_info)

                    cc_name = f"CC.{bsm_name}.{src}"
                    cc_info = {tc.NAME: cc_name,
                               tc.SRC: bsm_name,
                               tc.DST: src,
                               tc.DISTANCE: distance,
                               tc.DELAY: cc_delay}
                    config[tc.ALL_C_CHANNEL].append(cc_info)
            else:
                raise NotImplementedError("Unknown type of quantum connection")